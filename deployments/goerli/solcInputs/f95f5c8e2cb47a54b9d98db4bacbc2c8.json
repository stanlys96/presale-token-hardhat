{
  "language": "Solidity",
  "sources": {
    "contracts/PresaleWalao1.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2023-02-12\n*/\n\npragma solidity ^0.8.15;\n\n//SPDX-License-Identifier: MIT Licensed\n\ninterface IToken {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external;\n\n    function transfer(address to, uint256 value) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract PresaleWalao1 {\n    using SafeMath for uint256;\n\n    IToken public WES;\n    IToken public USDT = IToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    AggregatorV3Interface public priceFeedEth;\n\n    address payable public owner;\n\n    uint256 public tokenPerUsd = 4761904760000000000; //4.7 tokens for $1\n    uint256 public preSaleStartTime;\n    uint256 public soldToken;\n    uint256 public totalSupply = 1500000 ether; //presale tokens \n    uint256 public amountRaisedEth;\n    uint256 public amountRaisedUSDT; \n    uint256 public minimumDollar = 100000000; //min buy usdt\n    uint256 public minimumETH = 0.05 ether; //min buy eth\n    uint256 public constant divider = 100;\n\n    bool public presaleStatus;\n\n    struct user {\n        uint256 Eth_balance;\n        uint256 busd_balance;\n        uint256 usdt_balance;\n        uint256 token_balance;\n    }\n\n    mapping(address => user) public users;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"PRESALE: Not an owner\");\n        _;\n    }\n\n    event BuyToken(address indexed _user, uint256 indexed _amount);\n\n    constructor(address _wesAddress) {\n        owner = payable(0xf3f1A4EadA0D8a35d82421E303a139EBDC8E823f);\n        priceFeedEth = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        );\n        preSaleStartTime = block.timestamp;\n        presaleStatus = true;\n        WES = IToken(_wesAddress);\n    }\n\n    receive() external payable {}\n\n    // to get real time price of Eth\n    function getLatestPriceEth() public view returns (uint256) {\n        (, int256 price, , , ) = priceFeedEth.latestRoundData();\n        return uint256(price);\n    }\n\n    // to buy token during preSale time with Eth => for web3 use\n\n    function buyTokenEth() public payable {\n        require(presaleStatus == true, \"Presale : Presale is finished\");\n        require(msg.value >= minimumETH, \"Presale : Unsuitable Amount\");\n        require(soldToken <= totalSupply, \"All Sold\");\n\n        uint256 numberOfTokens;\n        numberOfTokens = EthToToken(msg.value);\n        WES.transfer(msg.sender, numberOfTokens);\n\n        soldToken = soldToken + (numberOfTokens);\n        amountRaisedEth = amountRaisedEth + (msg.value);\n        users[msg.sender].Eth_balance =\n            users[msg.sender].Eth_balance +\n            (msg.value);\n        users[msg.sender].token_balance =\n            users[msg.sender].token_balance +\n            (numberOfTokens);\n    }\n\n    // to buy token during preSale time with USDT => for web3 use\n    function buyTokenUSDT(uint256 amount) public {\n        require(presaleStatus == true, \"Presale : Presale is finished\");\n        require(amount >= minimumDollar,\"Minimum Amount is $100\"); \n        require(soldToken <= totalSupply, \"All Sold\");\n\n        USDT.transferFrom(msg.sender, address(this), amount);\n\n        uint256 numberOfTokens;\n        numberOfTokens = usdtToToken(amount);\n\n        WES.transfer(msg.sender, numberOfTokens);\n        soldToken = soldToken + (numberOfTokens);\n        amountRaisedUSDT = amountRaisedUSDT + (amount);\n        users[msg.sender].usdt_balance =\n            users[msg.sender].usdt_balance +\n            (amount);\n        users[msg.sender].token_balance =\n            users[msg.sender].token_balance +\n            (numberOfTokens);\n    }\n\n    // to check percentage of token sold\n    function getProgress() public view returns (uint256 _percent) {\n        uint256 remaining = totalSupply -\n            (soldToken / (10**(WES.decimals())));\n        remaining = (remaining * (divider)) / (totalSupply);\n        uint256 hundred = 100;\n        return hundred - (remaining);\n    }\n \n    function stopPresale(bool state) external onlyOwner {\n        presaleStatus = state;\n    }\n\n    // to check number of token for given Eth\n    function EthToToken(uint256 _amount) public view returns (uint256) {\n        uint256 EthToUsd = (_amount * (getLatestPriceEth())) / (1 ether);\n        uint256 numberOfTokens = (EthToUsd * (tokenPerUsd)) / (1e8);\n        return numberOfTokens;\n    }\n\n    // to check number of token for given usdt\n    function usdtToToken(uint256 _amount) public view returns (uint256) {\n        uint256 numberOfTokens = (_amount * (tokenPerUsd)) / (1e6);\n        return numberOfTokens;\n    }\n\n    // to change Price of the token\n    function changePrice(uint256 _price) external onlyOwner {\n        tokenPerUsd = _price;\n    }\n\n    // to change preSale time duration\n    function setPreSaleTime(uint256 _startTime) external onlyOwner {\n        preSaleStartTime = _startTime;\n    }\n\n    // transfer ownership\n    function changeOwner(address payable _newOwner) external onlyOwner {\n        owner = _newOwner;\n    }\n\n    // change tokens\n    function changeToken(address _token) external onlyOwner {\n        WES = IToken(_token);\n    }\n\n       // change minimum buy\n    function changeMinimumLimits(uint256 _inDollar, uint256 _inEth) external onlyOwner {\n        minimumDollar = _inDollar;\n        minimumETH    = _inEth;\n    }\n    // change supply\n    function changeTotalSupply(uint256 _total) external onlyOwner {\n        totalSupply = _total;\n    }\n    //change USDT\n    function changeUSDT(address _USDT) external onlyOwner {\n        USDT = IToken(_USDT);\n    }\n\n    // to draw funds for liquidity\n    function transferFundsEth(uint256 _value) external onlyOwner {\n        owner.transfer(_value);\n    }\n\n    // to draw out tokens\n    function transferTokens(IToken token, uint256 _value) external onlyOwner {\n        token.transfer(msg.sender, _value);\n    }\n\n    // to get current UTC time\n    function getCurrentTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    // to get contract Eth balance\n    function contractBalanceEth() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    //to get contract USDT balance\n    function contractBalanceUSDT() external view returns (uint256) {\n        return USDT.balanceOf(address(this));\n    }\n\n    // to get contract token balance\n    function getContractTokenApproval() external view returns (uint256) {\n        return WES.allowance(owner, address(this));\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}